# 最短路
## 题目描述
一棵 n 个点的有根树，以 1 号点为根，走一条边需要花费相应的代价，任意深度相差为 1 的点之间可以相互跳跃，花费代价为 p ，求 s 走到 t 的最小代价。
## 输入
第一行包含一个整数 T ，表示数据组数。

对于每组数据，包含若干行，第一行四个整数 n,p,s,t，意义见题目描述。 接下来 n−1 行描述这棵树，每行三个整数 u,v,w，表示走一条连接 u 和 v 号点的边的代价为 w 。

其中，$1\leqslant T\leqslant 20$，$1\leqslant n\leqslant 10^5$,$1\leqslant s,t,u,v\leqslant n$,$0\leqslant p,w\leqslant 10^9$
## 输出
对于每组数据，输出一行，格式为 Case #number: result，其中 number 表示这是第 number 组数据，而 result 为答案。
## 输入样例
```
2
2 1 1 2
1 2 3
7 999999999 2 7
1 2 1000000000
1 3 1000000000
2 4 999999998
3 5 1000000000
5 6 1000000000
6 7 999999998
```
## 输出样例
```
Case #1: 1
Case #2: 2999999995
```
## 解题思路
此题难点是“任意深度相差为 1 的点之间可以相互跳跃”这一条件，因为树准确地来说应该要看做一个有向图，这一条件可以解决树中非直系前后代关系的节点间不可达的问题，但也加大了难度，因为极端情况下相当于“任意两点之间都存在路径”，如果用Dijkstra算法的话，仅这一条件带来的边数的增加就接近$N^2$，一般来说，这种数量级的运算肯定是过不了的。由于存在很多可能的路径，这些路径比原来树的边还要多得多，如果把可能的路径画出来，得到的图应该已经不能看做树了，所以直接去掉某些树枝都行不通，并没有一种有效方法去判断哪些边肯定不可能是最短路径上的边。

想到这里就陷入僵局，后来还是看了别人的题解才找到办法，就是：在每两层节点中间增加两个中间节点，所有跳跃都通过中间节点进行，一个中间节点负责向下跳跃，一个负责向上跳跃，原来的顶点到中间节点的花费都为p/2。这样当然也会增加边，但增加的边数是4*N，虽然也不少，但是当N很大时相比$N^2$就少得太多了。

解决了这个问题，其他就没什么了。看来编程也像做几何题，有时候也需要辅助线，要脑洞才行。一般都是想着怎么去减少节点，怎么会去增加节点呢？但这个办法表面上看增加了节点，但事实却是大大地减少了边！