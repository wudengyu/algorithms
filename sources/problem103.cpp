/*双“11”的抉择
 *动态规划
 *设dp[i][j]表示前i个物品取j个的解。那么，当j<=a[i]时，dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+……+dp[i-1][0]
 *若是按照『填表』的动作，相当于每一个单元格的值等于上一行从第0列到本列的累计，所以，dp[i][j]=dp[i-1][j]+dp[i][j-1]，
 *从数学上解释就是：从i个物品中选j个可以分两类：一类是不取物品i，取法有dp[i-1][j]种，一类是取1个物品i，有dp[i][j-1]种。
 *根据题意，取1个跟取几个是同样的方案。事实上，取物品i的个数是固定的，因为必须保证最终取物品的总数是j。
 *当j>a[i]时，第一个式子不能累加到dp[i-1][0]因为这个方案表示前i-1个物品里选0个，那么到选择i物品时就必须选择j个，但是i
 *物品的数量不够j个。也就是当j-a[i]=1时，需要从dp[i][j-1]里去掉最后一个dp[i-1][0]，当j-a[i]=2时，需要从dp[i][j-1]
 *里去掉最后两个，不过由于上一步已经去掉了dp[i-1][0]，所以实际还是只需要去掉最后一个dp[i-1][1]，总之，在运算过程中，j是
 *逐步递增的，所以当j>a[i]时，每一步都是去掉dp[i-1][j-a[i]]也就是dp[i-1][0]、dp[i-1][1]、逐步去掉了。
 */
#include <iostream>
using namespace std;
int main(){
    int N,m,M,a[1001];
    int dp[1001][1001];
    while(!(cin>>N>>m>>M).eof()){
        for(int i=1;i<=N;i++){
            cin>>a[i];
            dp[i][0]=1;
        }
        for(int i=1;i<=m;i++)
            dp[0][i]=0;
        dp[0][0]=1;
        for(int i=1;i<=N;i++){
            for(int j=1;j<=m;j++){
                dp[i][j]=(dp[i-1][j]+dp[i][j-1])%M;
                if(j>a[i])
                    dp[i][j]=(dp[i][j]-dp[i-1][j-a[i]-1]+M)%M;
            }
        }
        cout<<dp[N][m]<<endl;
    }
}