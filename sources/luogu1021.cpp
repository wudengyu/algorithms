#include<iostream>
#include<cstring>
using namespace std;
int a[15],ans[15],dp[15];
int n,k;
void solve(int s[],int pos,int dp[],int ans[]){
/*根据数组s的前pos个数，计算出可以贴n张邮票的情况下，可以组合出的连续的最大值；
 *这是一个完全背包问题。未优化时：dp[i][j]表示使用前i种邮票，组合出j面值时的最小张数，
 *那么dp[i][j]与dp[i-1][]有关，即：对于第i种邮票，可以使用0、1、2、……、n次，只是用
 *几次就需要把原来用的取出几张来，那么dp[i][j]就是dp[i-1][j-k*a[i]]+k（0<=k<=n）
 *当k=0即dp[i-1][j]表示不用第i种邮票，只用前面i-1种组合出j面值需要的张数；
 *当K=1时dp[i-1][j-a[i]]+1表示用了1次第i种邮票，那么前面组合出的面值必须少i邮票的面值a[i]
 *k=2、3、……、n时同理，dp[i][j]等于其中最小的。在线性规划中，dp[i-1][……]都是上一步计算出的
 *上一步没有计算出来的实际上就是不可能组合出来的面值，需要用∞表示（因为这里是求最小值，所以不能用0）
 *即初始化dp数组时要用非常大的数。
 *实际编程时，降维优化显然是可行的。然后j-k*a[i]如果按推导过程直接写，那么是跳跃性的，有很多值没有处理
 *但是j-k*a[i]的意义无非就是组合出的面值，所以直接用一个循环变量，控制其从0到n*a[i]就行了。
 *这个子程序每当遍历出一个组合时就会被调用一次，但每次遍历深度相同的情况下只是最后一种邮票的面值不同，
 *所以每开始一个新的深度，可以把原来的dp数组保存，反复使用。否则的话每次都重头算。
*/
}
void dfs(int pos){
    if(pos<=k-1){
        for(int i=a[pos-1]+1;i<=dp[pos-1]+1;i++){
            a[pos]=i;
            solve(a,pos,dp,ans);
        }
        dfs(++pos);
    }
}
int main(){
    memset(a,0,sizeof(a));
    memset(df,0,sizeof(df));
    cin>>n>>k;
    a[0]=1;
    dfs(1);
}